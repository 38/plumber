/**
 * Copyright (C) 2017, Hao Hou
 * The service utilities
 **/
Service.for_each_element = function Service.for_each_element(serv, handler)
{
	var _get_func = function(name)
	{
		var ret = handler[name];
		if(ret == undefined) return function(){};
		return ret;
	}
	var node_handle = _get_func("node");
	var pipe_handle = _get_func("pipe");
	var port_handle = _get_func("port");
	var input_handle = _get_func("input");
	var output_handle = _get_func("output");
	for(var key in serv)
	{
		var sp = split(key, "@");
		var lsp = len(sp);
		if(lsp == 1) 
			node_handle(key, serv[key]);
		else if(sp[0] == "")
		{
			if(lsp == 2)
			{
				var src_node = sp[1];
				var dests = serv[key];
				for(var src_port in dests)
				{
					/* Key is port name and value should be nodeName@portName */
					var dsp = split(dests[src_port], "@");
					var dst_node = dsp[0];
					var dst_port = dsp[1];
					pipe_handle(src_node, src_port, dst_node, dst_port);
				}
			}
			else if(lsp == 3)
			{
				var dst = split(serv[key], "@");
				var dst_node = dst[0];
				var dst_port = dst[1];
				if(sp[1] == "input")
				{
					if(sp[2] == "") input_handle(dst_node, dst_port);
					else port_handle(sp[2], dst_node, dst_port, "input");
				}
				else if(sp[1] == "output")
				{
					if(sp[2] == "") output_handle(dst_node, dst_port);
					else port_handle(sp[2], dst_node, dst_port, "output");
				}
			}
		}
	}
};

Service.build = function(serv)
{
	var _build = function _build_impl(serv, obj, build, prefix, nodemap) 
	{
		var nodes = {};
		var ports = {};
		var _deref_port = function _deref_port(node, port)
		{
			var nid = nodes[node];
			if(typeof(nid) == "dict") return nid[port];
			return {node: nid, port: port};
		};
		var node_handler = function _node_handler(name, def)
		{
			if(typeof(def) == "dict")
				nodes[name] = build(def, obj, build, prefix + "@" + name, nodemap);
			else
			{
				nodes[name] = __service_node(obj, def);
				if(nodemap != undefined) nodemap[prefix + "@" + name] = nodes[name];
			}
		};
		var pipe_handler = function _pipe_handler(src_node, src_port, dst_node, dst_port) 
		{
			var src = _deref_port(src_node, src_port);
			var dst = _deref_port(dst_node, dst_port);
			__service_pipe(obj, src["node"], src["port"], dst["node"], dst["port"]);
		};
		var port_handler = function _port_handler(name, node, port)
		{
			ports[name] = _deref_port(node, port);
		};
		var input_handler = function _input_handler(node, port)
		{
			var target = _deref_port(node, port);
			__service_input(obj, target["node"], target["port"]);
		};
		var output_handler = function _output_handler(node, port)
		{
			var target = _deref_port(node, port);
			__service_output(obj, target["node"], target["port"]);
		};

		Service.for_each_element(serv, {node: node_handler}); 
		Service.for_each_element(serv, {pipe: pipe_handler, port: port_handler, input: input_handler, output: output_handler});
		return ports;
	}
	
	return function Service.build(serv, nodemap) {
		var obj = __service_new();
		_build(serv, obj, _build, "", nodemap);
		return obj;
	}
}();

Service.start = function Service.start(serv) 
{
	var serv_obj = Service.build(serv);
	__service_start(serv_obj);
}

Service.visualize = function Service.visualize(serv) 
{
	print("digraph {");
	
	var obj = __service_new();

	var node_handler = function node_handler(name, def) 
	{
		var type = typeof(def);
		var ports;
		if(type == "string")
		{
			var nid = __service_node(obj, def);
			ports = __service_node_ports(obj, nid);
		}
		else if(type == "dict")
		{
			ports = {input:{}, output:{}};
			var in_count = 0;
			var out_count = 0;
			for(var key in def)
			{
				var parts = split(key, "@");
				if(len(parts) == 3)
				{
					if(parts[0] == "" && parts[2] != "")
					{
						if(parts[1] == "input")
							ports["input"][in_count ++] = parts[2];
						else if(parts[1] == "output")
							ports["output"][out_count ++] = parts[2];
					}
				}
			}
		}

		if(ports != undefined)
		{
			var inputs = ports["input"];
			var outputs = ports["output"];
			var _dump_ports = function(port_list, avoid)
			{
				var ret = "{"
				var sep = 0;
				for(var i in port_list)
				{
					var port = port_list[i];
					if(avoid[port] == undefined)
					{
						if(sep) ret += "|";
						ret += "<P" + port + ">" + port;
						sep = 1;
					}
				}
				return ret + "}";
			}
			var nodestr = "\tnode_" + name + "[shape = Mrecord, label = \"{" + 
						  	_dump_ports(ports["input"], {}) + 
							"|{<P__null__>N|" + name + "|<P__error__>E}|" + 
							_dump_ports(ports["output"], {__null__:1, __error__:1}) + "}\"];"
			print(nodestr);
		}
	}
	
	var _p = function (node, port)
	{
		return "node_" + node + ":P" + port;
	}

	var pipe_handler = function _pipe_handler(src_node, src_port, dst_node, dst_port) 
	{
		print("\t" + _p(src_node, src_port) + "->" + _p(dst_node, dst_port));
	}

	var port_handler = function _port_handler(name, node, port, dir)
	{
		var port_node = "port_" + name;
		print("\t" + port_node + "[shape = ellipse, label=\"" + name + "\"];");
		if(dir == "input")
			print("\t" + port_node + "->" + _p(node, port));
		else 
			print("\t" + _p(node, port) + "->" + port_node);
	}

	var input_handler = function _input_handler(node, port) 
	{
		print("\tinput[shape = ellipse];");
		print("\tinput->" + _p(node, port));
	}
	var output_handler = function _output_handler(node, port)
	{
		print("\toutput[shape = ellipse];");
		print("\t" + _p(node, port) + "->output;");
	}
	
	Service.for_each_element(serv, {node: node_handler, pipe: pipe_handler, port: port_handler, input: input_handler, output: output_handler});

	print("}");
}

Service.typeinfo = function typeinfo(serv) 
{
	var ret = {};
	var nodes = {};
	var obj = Service.build(serv, nodes);
	var port_list = {};
	for(var node in nodes)
		port_list[node] = __service_node_ports(obj, nodes[node]);
	
	for(var node in nodes)
	{
		var nid = nodes[node];
		var inputs = port_list[node]["input"];
		var outputs = port_list[node]["output"];
		for(var i in inputs)
			ret[node + "@" + inputs[i]] = __service_port_type(obj, nid, inputs[i]);
		for(var i in outputs)
			ret[node + "@" + outputs[i]] = __service_port_type(obj, nid, outputs[i]);
	}
	return ret;
}
